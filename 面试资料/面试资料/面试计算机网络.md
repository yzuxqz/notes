# 计算机网络

## UDP和TCP是什么？ 它们的区别

是osi模型中的运输层中的协议 TCP提供可靠得到通信传输 而UDP则通常被用于广播和细节控制交给应用的通信传输

## 区别

1.TCP面向连接（如打电话需要拨号建立连接） UDP面向无连接 即发送之前不需要建立连接

2.TCP提供可靠的服务 也就是说TCP连接传送的数据可以无差错，不丢失，不重复，且按序到达，而UDP尽自己最大的努力交付，即不保证可靠支付

3.TCP面向字节流，实际上是TCP把数据看成一串无结构的字节流；UDP是把它面向报文的。UDP没有拥塞控制，因此网络出现拥塞控制不会使源主机的发送速率降低（对实时运用很有用，如ip电话 实时视频会议

4.每一条TCP连接只能是点到点，UDP可以一对一 一对多 多对多

5.TCP首部开销是20字节，UDP的首部开销小，只有8字节

6.TCP的逻辑通信信号是全双工的可靠通信，UDP则是不可靠信道

UDP在什么场景会用到？广播 ip电话

## 进程和线程是什么?你是怎么理解的?

进程是资源管理的最小单位，线程是任务调度的最小单位

线程共用进程的所有资源

# http

## HTTP/1.0

HTTP/1.0版的主要缺点是，每个TCP连接只能发送一个请求。发送数据完毕，连接就关闭，如果还要请求其他资源，就必须再新建一个连接。

TCP连接的新建成功很高，因为需要客户端和服务器端三次握手，并且开始时发送效率较慢。所以，HTTP 1.0版本的性能比比较差。随着网页的外部加载资源越来越多，这个问题就愈发突出了。

为了解决这个问题，有些浏览器再请求时，用了一个非标准Connetion字段

```
Connetion：keep-alive
```

这个字段要求服务器不要关闭TCP连接，以便其他请求服用。服务器同样回应这个字段。

```
Connetion：keep-alive
```

一个可以复用的TCP连接就连接就建立了，直到客户端或者服务器主动关闭连接。但是，这不是标准字段，不同实现的行为可能不一致，因此不是根本的解决办法

## HTTP/1.1

目前最流行的版本

###  持久化连接

1.1版的最大变化，就是引入了持久化连接，即TCP连接默认不关闭，可以被多个请求复用，不用声明 Connetion：keep-alive

客户端和服务器端发现对方一段时间没有活动，就可以主动关闭连接。不过，规范的做法时，客户端在最后一个请求时，发送Connection：close。明确要求服务器关闭TCP连接

目前，对于同一个域名，大多数浏览器允许同时建立6个持久化连接

### 管道机制

1.1版还引入了管道机制，即在同一个TCP连接里面，客户端可以同时发送多个请求。这样就进一步改进了HTTP协议的效率。

举例来说，客户端需要请求两个资源。以前的做法时，在同一个TCP连接里面，先发送A请求，然后等待服务器做出回应，收到后再发送B请求。管道机制则是允许浏览器是同时发出A请求和B请求，但是服务器还是按照顺序，先回应A请求，完成后再回应B请求。

### Content-Length字段

一个TCP连接现在可以传送多个回应，势必就要有一种机制，区别数据包是属于哪一个回应的。这就是Content-Length字段的作用，声称本次回应的数据长度

```
Content-Length：3495
```

上面代码告诉浏览器，本次回应的长度是3495个字节，后面的字节就属于下一个回应了。

在1.0版中，Content-length字段不是必须的，因为浏览器发现服务器关闭TCP连接，就表面收到的数据包已经全了。

### 分块传输编码

使用Content-Length字段的前提是，服务器发送回应之前，必须知道回应的数据长度。

对于一些很耗时的动态操作来说，这意味着，服务器要等到所有操作完成，才能发送数据，显然这样的效率不高。更好的处理方法时，产生一块数据，就发送一块数据，采用"流模式"取代"缓存模式"(buffer)。

因此，1.1版本可以不使用Content-Length字段，而使用"分快传输编码"。只要请求或回应的头信息有Transfer-Encoding字段，就表明回应将由数量未定的数据块组成。

```
Transfer-Enconding：chunked
```

每个非空的数据块之前，会有一个16进制的数值，表示这个块的长度。最后是一个大小为0的块，就表示本次回应的数据发送完了。下面是一个例子。

```

HTTP/1.1 200 


Content-Type: text/plain
Transfer-Encoding: chunked

25
This is the data in the first chunk

1C
and this is the second one

3
con

8
sequence

0
```

### 其他功能

1.1版还增加了许多动词方法：PUT PATCH HEAD OPTIONS DELETE。

另外，客户端请求的头信息新增了Host字段，用来指定服务器的域名。

```
Host：www.example.com
```

有了Host字段，就可以将请求发往同一太服务器上的不同网站，为虚拟主要的兴起打下了额基础。

### 缺点

虽然1.1版允许服用TCP连接，但是同一个TCP连接里面，所有的数据通信时按次序进行的。服务器只有处理完一个回应，才会进行下一个回应，要是前面的回应特别慢，后面就会有许多请求排队等着，这称为"队头阻塞"

为了避免这个问题，只有两种方法：一是减少请求数，二是同时多开持久化连接。这导致了很多的网页优化技巧，比如合并脚本和样式表、将图片嵌入CSS代码，域名分片等等。如果HTTTP协议设计得更好一些，这些额外的工作是可以避免的。

## SPDY协议

2009年，谷歌公开了自行研发的SPDY协议，主要解决HTTP/1.1效率不高的问题。

这个协议在Chrome浏览器上可行以后，就被当作HTTP/2的基础，主要特征都在HTTP/2之中得到继承。

## HTTP/2

2015年,HTTP/2发布，他不叫HTTP/2.0,是因为标准委员会不打算再发布子版本了，下一个新版本将是HTTP/3

### 二进制协议

HTTP/1.1版的头信息是文本(ASCII编码),数据体可以是文本，也可以是二进制。

HTTP/2 则是一个彻底的二进制协议,头信息和数据体都是二进制，并且统称为"帧"：头信息帧和数据体帧。

二进制协议的一个好处是，可以定义额外的帧。HTTP/2定义了近十种帧，为将来的高级应用打下了基础。如果使用文本实现这个功能，解析数据将会变得非常麻烦，二进制解析则方便更多

### 多工

HTTP/2复用TCP连接，在一个连接里，客户端和浏览器都可以同时发送多个请求或回应，而且不按照顺序一一对应，这样就可以避免了"队头阻塞"。

举例来说，在一个TCP连接里面，服务器同时收到了A请求和B请求，于是先回应A请求，结果发现处理过程非常耗时，于是就发送A请求已经处理好的部分，接着回应B请求，完成后，再发送A请求剩下的部分。

这样双向的，实时的通信，就叫做多工。

### 数据流

因为HTTP/2的数据包是不按照顺序发送的，同一个连接里面连续的数据包，可能属于不同的回应，必须要对数据包做标记，指出它属于哪个回应。

HTTP/2将每个请求或者回应的所有数据包，称为一个数据流。每个数据流都有一个独一无二的编码，数据包发送的时候，都必须标记数据流ID，用来区分它是属于哪个数据流。另外还规定，客户端发送的数据段，ID一律为奇数，服务器发出的，ID为偶数。

数据流发送到一半的时候，客户端和服务器都可以发送信号 (RST_STREAM 帧)，取消这个数据流。1.1版取消数据流的唯一方法，就是关闭TCP连接。这就是说，HTTP/2可以取消某一次请求，同时保证TCP连接还打开着，可以被其他请求使用。

客户端还可以指定数据流的优先级。优先级越高，服务器就会越早回应。

### 头信息压缩

HTTP协议不带有状态，每次请求都必须附上所有信息。所以，请求的很多字段都是重复的，比如Cookie和User Agent，一模一样的内容，每次请求都必须附带，这会浪费很多带宽，也影响速度。

HTTP/2对这一点做了优化，引入了头信息压缩机制。一方面，头信息使用gzip或者compress压缩后再发送；另一方面，客户端和服务器端同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，以后就不发送同样字段了，只发送索引号，这样就提高速度了。

### 服务器推送

HTTP/2允许服务器未经请求，主动向客户端发送资源，这叫做服务器推送(server push)。

常见的场景就是客户端请求一个网页，这个网页里面包含了很多静态资源。正常情况下，客户端必须收到页面后，解析HTML源码，发现有静态资源，再发出静态资源请求。其实，服务器可以预期到客户端请求网页后，很可能会再请求静态资源，所以就主动把这些静态资源随着网页一起发送给客户端了。

## HTTP常用状态码

200 - 请求成功

204 - 同于请求执行成功，但是没有数据，浏览器不用刷新页面.也不用导向新的页面

301 - 永久重定向

304 Not Modified 为修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提交一个头信息指出客户端希望只返回在指定日期之后修改的资源

400 -客户端请求的语法错误，服务器端无法理解

​	产生原因：

​	 - 前提提交的数据格式和字段类型与后台的实体没有保持一致

​	 - 前端提交到后台的数据应该是JSON字符串类型，但是前端没有将对象 JSON.stringify转化成字符串。

​	解决方法：

​     - 对应字段的名称和类型保持一致。

​	 - 将obj对象通过JSON.stringify实现序列化

401 -当前请求需要用户验证

403 -服务器已经得到请求，但是拒绝执行

500 -服务器端在执行时发成错误，无法完成请求

## HTTP和HTTPS的区别

1.https协议需要到CA申请证书，一般免费的证书较少，因而需要一定费用

2.http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输

3.http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80端口，后者是443

4.http的连接非常简单是无状态的，https协议是由SSL+Http协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。(无状态的意思是其数据包的发送、传输和接受都是相互独立的。无连接的意思是指双方都不长久的维持对方的任何信息)

## SSL过程

ssl是安全套接字层的缩写，用于加密用户和服务器端之间通讯的技术

ssl的工作过程首先要进行服务器认证的阶段，客户端在向服务器端发送信息之后，就会产生一个新的会话链接，而服务器会根据客户的信息确定是否要生成新的主密钥，在密钥生成之后，双方的信息会通过密钥传输来进行，服务器会返回给客户一个主密钥认证的信息，这也是为了让客户认证服务器，之后会进行用户认证的阶段，用户会返回数字签名提问和公开密钥像服务器认证。

## HTTP1.0和HTTP1.1的一些区别

1.持久化连接

2.管道机制

3.Content-length

4.分块传输编码 采用"流传输"代替"缓存传输"

5.更多的请求方法 put delete head

6.host请求头

## HTTP2.0

1.二进制编码

2.多工 (多路复用) 即连接共享

3.数据流

4.头信息压缩

5.服务器端推送

## WebSocket的实现和应用

什么是WebSocket？

webSocket是HTML5中的协议，支持持久连续，http协议不支持持久性连续。http1.0和HTTP1.1都不支持持久化的连接，HTTP1.1中的keep-alive，讲多个http请求合并为1个

WebSocket是什么样的协议，具体有什么优点？

WebSocket是基于Http协议的，或者说借用Http协议来完成一部分握手，在握手阶段与Http是相同的。WebSocket，只要建立一次连接，就可以连续不断得到服务器端推送的消息，节约带宽和服务器端的压力

## Http请求的方式，HEAD方式

head：类似于get请求，只不过返回的响应中没有具体的内容，用户获取报头。

options：允许客户端查看服务器端的性能，比如说服务器支持的请求方式等等。

## 几个使用的BOM属性对象方法

首先Bom是浏览器对象。

### location对象

location.href 返回或设置当前文档的URL

location.search 返回URL中的查询字符串部分。例如 [http://www.dreamdu.com/dreamdu.php?](http://www.dreamdu.com/dreamdu.php?id=5&name=dreamdu)返回包括(?)后面的内容?id=5&name=dreamdu

location.hash 返回URL后面的内容，如果没有#，返回空

location.host 返回URL中域名部分 例如[www.dreamdu.com](http://www.dreamdu.com/)

location.hostname 返回URL中主域名部分 例如dreamdu.com

location.pathname 返回URL的域名后的部分 例如 http://www.dreamdu.com/xhtml/ 返回/xhtml/

location.port 返回URL中的端口部分 例如 http://www.dreamdu.com:8080/xhtml/ 返回8080

location.protocol 返回URL中的协议部分 例如 http://www.dreamdu.com:8080/xhtml/ 返回(//)前面的内容http:
l

location.assgin 设置当前文档的URL

location.repalce() 设置当前文档的URL，并且在在history对象的地址列表中移除这个URL location.repalce(url)。

location.reload() 重载当前页面

### history对象

history.go() 前进或后退指定的页面数

history.back() 后退一页

history.farward() 前进一页

### Navigator对象

navigator.userAgent -- 返回用户代理头的字符串表示(就是包括浏览器版本信息等的字符串)
navigator.cookieEnabled -- 返回浏览器是否支持(启用)cookie

## fetch发送两次请求的原因

fetch发送post请求的时候，总是发送两次，第一次状态码是204，第二次才成功？

因为你用fetch的post请求的时候，导致fetch第一次发送了一个Options请求，询问服务器是否支持修改的请求头，如果服务器支持，则第二次中发送的才是真正的请求。

## iframe是什么？ 有什么缺点？

定义：iframe是创建包含另一个文档的内联标签（即行内框架）。

提示：可以将提示文字放到iframe标签来 用来提示某些不支持iframe的浏览器

缺点：

会阻塞主页面的onload事件

搜索引擎无法解读这种页面，不利于SEO

iframe和主页面共享连接池，而浏览器相同区域有限制所以会影响性能。

## Doctype的作用？严格模式与混杂模式如何区别？它们有何意义？

Doctype声明于文档最前面，告诉浏览器是以何种方式来渲染页面，这里有两种模式，严格模式和混杂模式。

严格模式的排版和JS运作模式是以浏览器最高标准运行的。

混杂模式，向后兼容，模拟老式浏览器，防止浏览器无法兼容页面

## Cookie如何防范xss攻击

xss（跨站脚本攻击）是指攻击者在返回的HTML中嵌入Javascript脚本，为了减轻这种攻击，需要在HTTP头部配上，set-cookie: 

httponly-这个属性可以防止xss，它会禁止javascript脚本来访问cookie。

secure - 这个属性告诉浏览器仅在请求为https的时候发送cookie。

结果应该是这样的：Set-cookie=<cookie-value>......

## 一句话概括RESTFUL

就是用URL定位资源,HTTP描述操作

## 讲讲viewport和移动端布局

viewport 是用户网页的可视区域。

```html
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1">
```

content里面的属性必须知道

width:控制viewport的大小，可以是指定的值，或者特殊值，如device-width表示设备指定宽度。

height:和width相对应，表示高度。

initial-scale ：初始化缩放比例，也是当前页面第一次load的时候缩放的比例

maximum-scale：允许用户缩放的最大比例.

minimum-scale：允许用户缩放的最小比例。

user-scalable：用户是否可以手动缩放

## click在ios上有300ms延迟，原因及如何解决？

原因：当用户第一次点击屏幕之后，浏览器并不能立即判断用户是要进行双击缩放还是想要进行单机操作。因此，就有了300ms延迟

(1)简单粗暴,禁止缩放

```html
<meta name="viewpost" content="width=device-width,user-saclable=no"
```


(2)利用FastClick，其原理是：

检查到touchend事件后，立即触发模拟click事件，并且把浏览器300ms之后真正触发的事件给阻断掉。

## addEventListener参数

addEventListener(event,function,useCapture)

其中，event指定事件名，function指定事件触发时执行的函数；useCapture指定事件是否在捕获或者冒泡阶段执行 (布尔值)

##  tcp三次握手，一句话概括

客户端和服务器端都需要直到各自可收发，因此需要三次握手

## Cookie，sessionStorage、localStorage的区别

cookie始终在同源的http请求中携带(即使不需要)，即cookie在浏览器和服务器间来回传递。

cookie数据还有路径(path)概念，可以限制。cookie只属于某个路径下。

存储大小限制也不同，cookie数据不能超过4k，同时因为每次http请求都会携带cookie，所以cookie适合保存很小的数据，如会话标识。

webStorage虽然也有存储大小的限制，但是比cookie大的多，可以达到5M或者更大

数据的有效期不同 sessionStorage ：仅在当前的浏览器窗口关闭前有效；localStorage：始终有效，窗口或浏览器关闭也一直保存，因此用作持久数据；cookie：只在设置的cookie过期时间之前一直有效，即使窗口或者浏览器关闭。

作用域不同sessionStorage：不在不同的浏览器窗口中共享，即使是同一个页面；loacalStorage：在所有同源窗口都是共享的；cookie：在所有同源窗口中共享的

## Cookie和session的区别

1.cookie数据存放在客户的浏览器上。session数据存放在服务器上。

2.cookie不是很安全，别人可以分析存放在本地的cookie并进行cookie欺骗考虑到安全应当使用session

3.session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能考虑到减轻服务器性能方面，应当使用cookie。

4.单个cookie保存的数据不能超过4k，很多浏览器都限制一个站点最多保存20个cookie。而session则存储于服务器，浏览器对其没有限制

## iframe通信，同源和不同源两种情况，多少种方法。同源我说了，根据父页面

## 强，协商缓存

缓存分为两种：强缓存和协商缓存。

|          | 获取资源形式 | 状态码 | 发送请求到浏览器               |
| -------- | ------------ | ------ | ------------------------------ |
| 强缓存   | 从缓存取     | 200    | 否，直接从缓存中取             |
| 协商缓存 | 从缓存取     | 304    | 是，通过服务器告知缓存是否可用 |

强缓存相关字段有expires，cache-constrol。如果cache-control与expires同时存在的话，cache-control的优先级高于expries。

协商缓存相关字段有Last-Modified/if-Modified-Since，Etag/if-None-Match

## 讲讲304

304：自从上次请求后，请求的页面未修改过。服务器返回此响应时，不会返回页面内容。如果网页自请求者上次请求后再也没有更改过，你应将服务器配置未返回此响应(称为 if-Modified-Since HTTP 标头)。服务器可以告诉goolebot自上次抓取后页面没有更变，进而节省带宽和开销

## 强缓存、协商缓存什么时候用哪个

因为浏览器上的资源不是一直固定不变的，大多数情况下它会更更新，这个时候如果我们还访问本地缓存，那么对用户来说，那就相当于资源没有更新，用户看到的还是旧资源；所以我们希望浏览器上的资源更新了浏览器就请求新资源，没有更新就使用本地缓存，以最大程度的减少因网络请求而产生的资源浪费

## 前端优化

降低请求量：合并资源，减少HTTP请求数，minify/gzip压缩。

加快请求速度：预解析DNS，减少域名数，并行加载，CDN分支。

缓存：HTTP协议请求缓存，离线缓存 manifest，离线数据缓存localStorage。

渲染：JS/CSS优化，加快顺序，服务器渲染。

## GET和POST的区别

get参数通过url传递，post放在request body中。

get请求在url传递参数是有长度限制的，而post没有。

get比post更不安全。应为参数直接暴露在url中，所以不能用来传递敏感信息。

get请求只能进行url编码，而post支持多种编码方式。

get请求参数会被完整保存在浏览器历史记录里，而post种的参数不会被保存。

get和post本质上就是tcp连接，并无差别，但是由于http的规定和浏览器/服务器的限制，导致他们在应用过程中体现出一些不同。

get产生一个tcp数据包。post产生两个tcp数据包。

## 301和302区别

301永久重定向，302是临时重定向。

301比较常用的是使用域名跳转。302用来做临时跳转 比如未登录的用户访问用户中心重定向到登录页面。

## HTTP支持的方法

get post delete head options put 

## 如何画一个三角形

边框均分原理

```
div{
	width:0px;
	hight:0px;
	border:100px solid;
	border-top-color:red;
	border-right-color:transparent;
	border-bottom-color:transparent;
	border-left-color:transparent;
}
```

## 状态码304和200

状态码：200。请求已成功，请求希望的响应头或者数据题将随时返回。即返回的数据为全量的数据，如果文件不通过GZIP压缩的话，文件有多大，则有多大的传输量。

状态码：304。客户端发送一个带条件的get请求且该请求已被允许。而文档内容（自上次访问来说）并没有改变。则服务器应当返回这个状态码。即客户端和服务器端只通过传输很少的数据量来做文件的验证，如果没有文章修改过，则不需要返回全量的数据。

## 说一下浏览器缓存

缓存分为两种：强缓存和协商缓存，根据响应的header内容来决定。

强缓存相关字段有expires，cache-control。如果cache-control与expires同时存在的话，cache-control的优先级高于expires。

协商缓存相关字段有Last-Modified/if-Modified-Since，Etag/if-None-Match。

## HTML5新增的元素

html5为了更好的实践web语义化，增加了header、footer，nav，asdie，section等语义化标签，在表单方面，为了增强表单，为input增加了color，email，data，range等属性，在存储方面提供了sessionStorage，localStorage，和离线缓存，通过这些存储方式方便数据在客户端的存储和获取，在多媒体方面规定了音频和视频元素audio和vedio，另外还有地理定位，canvas画布，拖放，多线程编程的web worker和websocket协议。

## 从一个url地址到最终页面渲染完成，发生了什么

1.DNS解析：将域名地址解析为ip地址。

2.TCP三次握手。

3.发送请求。

4.响应请求。

5.渲染页面(构建dom树和cssom树)。

6.断开连接 tcp四次挥手。

## cookie和session的区别，localstorage和sessionstorage的区别

cookie和session都是用来存储用户信息的。cookie是客户端存储。session是服务器端存储。cookie存放在客户端不安全，所以cookie一般用来存放不敏感的信息，比如用户设置的网站主题，敏感信息用session存储，比如用户信息。cookie是确实存在的，session是会话概念

session一定时间内存放在服务器端，但是随着访问增多，会影响服务器端的性能，所以考虑性能方便应该使用cookie。

单个cookie存储不能超过4k，一个浏览器最多可能有20个cookie存储。session存储在服务器上浏览器对其没有限制。

下面从几个方向区分一下cookie，localstorage，sessionstorage的区别

1.生命周期：

cookie可以设置失效时间，否则默认为关闭浏览器时消失。

localstorage：除非手动删除，否则永久保存。

sessionstorage：仅在当前页面会话下有效，关闭页面或浏览器后就会清除。

2.存放数据：

cookie：4k

webstorage：5M作用

3.http请求：

cookie：每次都会携带在http头中，如果使用cookie内容过多数据会带来性能问题。

另外两个：只在客户端中保存，不存于和服务器端通信。

4.易用性：

Cookie：需要程序员自己封装，原生的cookie接口不友好

其他两个：即可采用原生接口，亦可再次封装。

5.应用场景：

从安全性来说，因为每次http请求都会携带cookie信息，这样浪费了带宽，所以cookie应该尽可能的少用，此外cookie还需要指定作用域，不可以跨域调用，限制很多，但是用户识别登录来说，cookie比storage好用，其他情况下还是用storage，localstorage可以用来在页面传递参数，sessionstorage可以用来保存一些临时的数据，防止用户刷新页面后丢失了一些参数。

## 常见的HTTP的头部

可以将http首部分为通用首部，请求首部，响应首部，实体首部。

通用首部 表示一些通用信息 比如data表示文档创建时间

请求首部 就是请求报文中独有的，如cookie，和缓存相关的如if-Modified-Since

响应首部 就是响应报文中独有的，如set-cookie，和重定型相关的location

实体首部 用来描述实体部分。如alow用来描述可执行的请求方法，content-type描述主题类型，content-Encoding描述主题的编码方式。

## HTTP2.0的特征

1.内容安全，应为http2.0是基于https的，天然具有安全特性，通过http2.0特征可以避免单纯使用https的性能下降

2.二进制格式，http1.x的解析是基于文本的，http2.0将所有的传输信息分割为更小的信息和帧，并对他们采用二进制格式编码，基于二进制可以让协议有更多的扩展性，比如引入了帧来传输数据和指令。

3.多路复用，这个功能相当于是长连接的增强，每个request请求可以混合在一起，接收方可以根据request的id将request再归属到各自不同的服务端请求里面，另外多路复用

中也支持了流的优先级，允许客户端告诉浏览器那些内容是更优先级的资源，可以传输。

1.二进制编码 2.多工 多路复用 共享连接 3.数据流 4.信息头压缩 5.服务器端推送

## cache-control的值有哪些 ！！！

cache-control是一个通用信息头字段被用于HTPP请求和响应中，通过指令实现缓存机制，这个缓存指令是单向的，常用的取值有private，no-cache，max-age，must-revalidata等，默认为private。

## 浏览器再生成页面的时候，会生成那两颗树

dom树和cssom规则书

当浏览器接受到服务器相对应来的html文档的后，会遍历文档节点，生成DOM树。

cssom规则树由浏览器解析css文件生成。

## csrf和xss的网络攻击及防范

CSRF：跨站请求伪造，可以理解为攻击者盗用用户的身份，以用户的名义发起恶意请求。比如这个制造攻击的网站使用一张图片，但是这种图片的连接确实可以更改数据库的，这时候攻击者就可以用用户的名义操作这个数据库，防御方式，尽量使用post请求，使用验证码，检查https头部的refer，使用token。

XSS：跨站脚本攻击，是说攻击者通过输入恶意的脚本，在用户浏览页面的时候进行攻击，比如获取cookie，或者其他用户的信息，可以分为存储型和反射型，存储型是攻击者输入一些数据并且存储到了数据库中，其他浏览者看到的时候攻击，反射性的话不在存储在数据库中，往往表现为将攻击代码放到url的请求参数中。防御的话为cookie设置httponly属性，对用户输入进行过滤，输出进行编码

## 怎么看网站的性能如何

检查页面加载时间一般由两种方式，一种是被动检查：就是被检测的页面置入脚本或者探针，当用户访问页面时，探针自动采集数据并传回数据库进行分析，另一种主动检测的方式，即主动的搭建分布式受控环境，模拟用户发起页面请求，主动采集性能数据并分析，在检测的精度上，专业的第三方工具效果更佳，比如说性能极客。

## 接受HTTP协议(特征)

HTTP是一个基于TCP/IP通信协议来传输数据，HTTP是一个属于应用层的面向对象的协议，由于其便捷，快速的放肆，适用于分布式超媒体信息系统。它于1990年提出，经过几年的使用于发展，得到不断完善和扩展。HTTP协议工作于客户端-服务端架构之上。浏览器作为http客户端通过URL向http服务端即WEB服务器发送所有请求。Web服务器根据接受到的请求后，向客户端发送响应信息。

## 描述一下XSS和CRSF攻击？防御方式？

XSS：跨站脚本攻击，攻击者在返回的html中嵌入js脚本。就发生了xss攻击。分为反射型(非持久型) 存储型(持久型) DOM

反射型：发送请求时，xss代码出现在URL中，作为输出提交到服务器端解析后响应，xss代码随着响应内容一起返回到浏览器，最后浏览器解析执行代码。存储型：攻击者输入一些数据传入数据库中，其他用户看到的时候进行攻击。

DOM：DOM XSS代码并不需要服务器参与，触发XSS靠的是浏览器端的DOM解析，完全是客户端的事

CSRF：跨站请求伪造。当用户访问一个网站时，其Cookie信息还没有过期的情况下，伪装者伪造一个链接发送受害者并欺骗让其点击，从而形成CSRF攻击。

XSS防御的总体思路：对输入进行过滤，对输出进行编码，通过设置cookie httponly 禁止js脚本执行cookie。也可以设置只有在https协议下才可以发送cookie。

防御CSRF攻击主要有三种策略：尽量使用POST 验证HTTP refer字段；在请求地址中设置token并验证，在HTTP头中设置自定义属性并进行验证。

区别 

XSS 运用的是用户对网站的信任

CSRF 运用的是网站对用户的信任

## 200和304的区别

200 请求成功 一般使用get和post请求

304 为修改。所请求的资源未修改，服务器返回此状态码，不会返回任何资源。因为客户端通常会缓存访问过的内容。

## 对称加密和非对称加密

对称加密：A和B之间的通讯数据都是同一套密钥来进行加密解密的

优点：

简单快捷，密钥较浅，且破译困难。

缺点：

如果用户一旦多的话，管理密钥也是一种困难。不方便直接沟通两个用户之间怎么确定密钥。这其中就会有密钥泄露的风险，以及存在更换密钥的需求。

对称加密通常有DES，IDEA，3DES加密算法

非对称加密：用公钥和私钥来加解密算法。比如，A对公钥加密过的东西只能通过A的私钥来解密。同理，A私钥加密过的东西只能通过A的公钥来解密。顾名思义，公钥是公开的，别人可以获取的到；私钥是私有的，只能自己拥有。

优点：

比对称加密耗时

缺点：

加解密比对称加密耗时

常见的非对称加密算法有：RSA、ECC（移动设备用）、Diffie-Hellman、El Gamal、DSA（数字签名用

## TCP三次握手，四次挥手

客户端    服务器

SYN   	

​				SYN+ACK

ACK 

第一次握手：客户端对服务端说：服务端你好，我现在想跟你建立一次TCP连接；

第二次握手：服务端对客户端说：客户端你好，我收到你想跟我建立连接的消息了，我马上就去为我们的连接做准备（分配资源），我现在也发个消息（ACK）给你，你看看你可以收到我发的消息吗？

第三次握手：客户端对服务端说：收到了收到了，我收到了你给我的消息（ACK）了，看来我们连接是没问题的，我们来建立连接吧~



FIN				

​					ACK

​					FIN 

ACK

第一次握手：客户端告诉服务端：我的数据已经都发送完了，我准备断开连接了哈；

第二次握手：服务端告诉客户端：好的，我收到了你准备断开连接的请求了，但是我还有数据没有发送完，你再等等哈，我发完了会告诉你的；

第三次握手：服务端告诉客户端：好的，我所以数据都发完了，我也准备跟你断开连接了；你再给我挥次手我就知道你断开了连接，我也就马上断开；此时服务端会给自己设置一个定时器~（这里有个定时器是重点！）。如果客户端立即关闭当ack丢失的时候，服务器端将进行重传，而客户端已经关闭了，导致服务器端一直处于最后确认状态

第四次握手：客户端告诉服务端：好的，我断开连接了~，   服务端收到客户端断开连接的消息后服务端自己也断开了连接；