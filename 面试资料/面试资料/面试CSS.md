## CSS盒模型

用来装页面上的元素区域。css中的盒模型包含IE盒子模型和标准的W3C盒子模型。box-sizing(三个值)：border-box，padding-box，content-box

区别：就算是width的包含范围，在标准的盒子模型中，width指content部分的宽度，在ie盒子模型中，width表示content+padding+border这三部分的高度，故在计算整个盒子的高度时存在着差异：

标准盒子模型的盒子宽度：width

IE盒子模型的盒子宽度：左右的border+左右的padding+width。

在CSS3中引入了box-sizing属性，box-sizing：content-box 表示标准盒子模型。box-sizing：border-box 表示的是IE盒子模型

回答：

```
盒模型都是由四种部分组成的：content padding margin border 

标准盒子模型和IE盒子模型的区别在于width和height时，所对应的范围不同。标准盒子模型的width和height属性的范围只包含content，而ie盒子模型包括content和padding和border。一般来说可以修改元素的box-sizing属性可以改变元素的盒模型 content-box标准盒子模型 border-box是ie盒子模型
```

## CSS盒子选择符有哪些

```
id选择器号(#myid)
类选择器(.myclassname)
标签选择器(div,h1,p)
属性选择器(a[rel="external"])
后代选择器(h1 p)
相邻后代选择器(子)选择器(ul>li)
兄弟选择器(li~a)
相邻兄弟选择器(li+a)
伪类选择器(a:hover,li:nth-child)
伪元素选择器(:before :after)
通配符选择器(*)
```

## ::before和:after中双冒号和单冒号有什么区别？解释一下这两个伪元素的作用

```
在css3中单冒号表示伪类，双冒号表示伪元素。但是为了兼容已有的伪元素写法，在一些浏览器中单冒号也可以表示伪元素。
伪类一般匹配元素的一些特殊状态比如hover或者link等，而伪元素一般匹配特殊的位置比如after，before等
```

## 伪类和伪元素的区别

```
伪类和伪元素都是用来修饰不在文档树种的部分，比如一句话种的第一句话或者列表种第一个元素。
伪类用于当已有的元素处于某个状态时，为其添加对应的样式，这个状态是根据用户行为而改变的。比如当用户悬停在指定的元素时，我们可以通过:hover来描述这个状态。
伪元素是创建一些不在文档树中的元素，并为其添加样式。他们允许我们为元素的某部分设置样式。比如说，我们通过::before来用于在一个元素前增加一些文本，并为这些文本添加样式。虽然用户可以看到这些文本，但是这个文本实际不在文档书中。
但是有些浏览器单冒号也可以表示伪元素，由于旧版w3c规范未对其进行特别区分
```

## CSS中有哪些属性可以继承

```
每一个属性在定义中都会指定这个属性是否具有继承性，一个具有继承性的属性会在没有指定值的时候，会使用父元素的同属性的值。
一般具有继承性的属性有，字体相关的属性:font-size和font-wight。文本相关的，color和text-align等。
表格的一些布局属性、列表属性list-style等。还有光标属性cursor、元素可见性visibility。
当一个属性不是可继承属性的时候，我们也可以通过设置为inherit来使它从父属性那获取同属性名的值来继承
```

## CSS优先级算法如何计算？

```
首先判断一条属性声明是否有权重。也就是 是否在声明后面又!important。一条声明如果加上了权重。那么它的优先级就是最高的。前提是它之后不再出现相同权重。如果权重相同，我们则需要去比较匹配规则的特殊性。
一个匹配规则一般由多个选择器组成，一条规则的特殊性由组成它的选择器的特殊性累加而成。选择器的特殊性可以分为四个等级。
第一个等级是行内样式为1000，第二等级是id选择器，为0100，第三等级是类选择器、类类选择器和属性选择器是0010，
第四个等级是元素选择器和伪元素选择器，为0001。规则中每出现一个选择器，就将它的特殊性进行叠加，这个叠加只限于对应的等级的叠加，不会产生进位。选择器特殊性值的比较是从左向右排序的，也就是说以1开头的特殊值要比以0开头的特殊值要大。
比如说特殊值为1000的规则优先级就比特殊值0999的规则高。如果两个规则的特殊性值相等的时候，那么就根据他们的引入顺序，后出现的规则的优先级高

个人理解：内联样式(标签内选择符)>id选择器>类选择器>标签选择器 !important优先级最高
```

## 关于伪类LVHA的解释？

```
link: 未被访问的元素
visited：已经访问过的元素
hover：移动到某元素上发生的事件
active ：用于激活状态的元素(即一个a标签当鼠标点击但不放开时发生的事件，介于鼠标按下与鼠标松开之间)

a标签的状态由四种状态：链接访问前、访问后，鼠标滑过、激活，分别对应四种伪类：link :visited :hover :active;
当链接未访问过时：(1)当鼠标滑过链接时，同时满足link，:hover 两种状态，要改变a标签的颜色，就必须将：hover伪类在:link伪类后面声明；
(2) 当鼠标点击激活a链接时，同时满足：link,hover,active三种状态，要显示a标签激活时的样式(:active)，必须将:active声称放到:link和:hover之后。因此得出LVHA这个顺序。
当链接访问过时，情况基本同上，总比不过将：link换成visited。
这个顺序能不能变？可以，但也知识:link和：visited可以交换位置，因为一个链接要么访问过要么没访问过，不可能同时满足，也就不存在覆盖的问题。
```

## CSS 新增伪类有哪些?

```
elem:nth-child(n) 选中父元素下的第n个元素并且这个子元素的标签名为elem，b可接受具体的数值，也可以接受参数。
elem:nth-last-child(n) 作用同上从后往前找
elem:last-child 选中最后一个子元素
elem:only-child如果elem是父元素下唯一的子元素，则选中之。
elem:nth-of-type(n)选中父元素下第n个elem类型元素，n可以接受具体的数组，也可以接受函数。
elem:empty选中不包括子元素和内容的elem类型元素。
elem:target选择当前活动的elem元素。
:not(elem) 选中非elem元素的每个元素。
:enabled 控制表单控件的禁用状态。
:disabled 控制表单控件的禁用状态。
:checked 单选框和复选框被选中
```

## 如何居中

```css
div {
  position: absolute;
  width: 300px;
  height: 300px;
  margin: auto;
  top: 0;
  left: 0;
  bottom: 0;
  right: 0;
  background-color: pink; /*方便看效果*/
}
```

```css
/*确定容器的宽高宽500高300的层设置层的外边距div{*/
div {
    position:absolute;/*绝对定位*/
    width:500px;
    height:300px;
    top:50%;
    left:50%;
    margin:-150px -250px;/*外边距为自身宽高的一半*/
    background-color:pink;/*方便看效果*/
}
```

```css
/*未知容器的宽高，利用`transform`属性*/
div {
  position: absolute; /*相对定位或绝对定位均可*/
  width: 500px;
  height: 300px;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  background-color: pink; /*方便看效果*/
}
```

```css
/*利用flex布局实际使用时应考虑兼容性*/
.container {
  display: flex;
  align-items: center; /*垂直居中*/
  justify-content: center; /*水平居中*/
}
.containerdiv {
  width: 100px;
  height: 100px;
  background-color: pink; /*方便看效果*/
}
```

```
1.我们可以利用margin:auto来实现元素水平居中
2.利用绝对定位，设置四个方向的值都为0，并将margin设置为auto,由于高度固定，因此对应方向实现水平，可以实现水平和垂直方向上的居中。
3.利用绝对定位，设置top 50% left 50%定位到页面的中心 再通过margin负值来调整元素的中心到页面中心。
4.设置top 50% left 50%定位到页面的中心 通过transform:transalte(-50%,-50%);
5.利用flex布局，通过align-items:center和justify-conten:center设置容器的垂直和水平方向为居中对齐，然后它的子元素也可以实现垂直和水平的居中。
```

## display有哪些值？说明他们的作用。

```
block 块级型，默认宽度为父元素宽度，可设置宽高，换行显示。
none 元素不显示，并从文档流中移除。
inline 行内元素类型。默认宽度为内容宽度，不可设置宽高，同行显示。
inline-block 默认宽度为内容宽度，可以设置宽高，同行显示。
list-item 像块类型元素一样显示，并添加样式列表标记。
table 此元素作为块级表格来显示。
inherit 规定从父元素继承display的值。
```

## postion的值relative和absolute定位原点是？

```
absolute
生成绝对定位的元素，相对于值不为static的第一个父元素的paddingbox进行定位，也可以理解为离自己这一级最近的一级的position设置为absolute或者relative的父元素的paddingbox的左上角为原点的。
fixed
生成绝对定位的元素，相对于浏览器窗口进行定位。
relative
生成相对定位的元素，相对于其元素本身所在正常位置进行定位。
static
默认值。没有定位，元素出现在正常流中(忽略top，bottom，left，right，z-index声明)。
inherit
规定从父元素继承postion属性的值
```

```
relative 相对定位，相对于元素本身的正常位置进行定位。
absolute 绝对定位，是相对于它的第一个position不为static的祖先元素的padding-box来进行定位。
这句话可以这样来理解，我们首先需要绝对定位中position中值不为static的祖先元素，然后相对于这个祖先元素的padding-box来进行定位，也就是说在计算定位距离的时候，padding的值也计算进去了
```

## CSS有哪些新特性？

```
新增css各种伪类选择器 (:not(input) :所有class不是"input"的节点)
圆角 border-radius：8px
多列布局 (multi-columnlayout)
阴影和反射 (shadow\Reflect)
文字特效 (text-shadow)
文字渲染 (Text-decoration)
线性渐变 (gradient)
旋转 (transform)
缩放、定位、倾斜、动画、多背景
例如：
transform:\scale(0.84,0.90)\translate(0px,-30px)\skew(-9deg,0deg)\Animation
```

## CSS3的Flexbox，以及使用场景

```
flex布局是css3新增的一种布局方式，我们可以同时设置一个元素的display属性值设置为flex从而使它成为一个flex容器，它的所有子元素都会成为它的项目。
一个容器默认有两条轴，一条水平轴，一条是与主轴垂直的交叉轴，我们可以使用flex-direction来指定主轴的方向。
我们可以使用justify-content来指定标签在主轴的排列方式，使用align-items来指定元素在交叉抽的排列方式。还可以使用flex-wrap来规定当一行排列不下时的换行方式。
对于容器中的项目，我们使用order属性来指定项目的排列顺序，还可以使用flex-grow来指定当前排列空间有剩余的时候，项目放大比例。还可以使用flex-shrink来指定当排列空间不足时，项目缩小比例。
```

## 用纯CSS创建一个三角形的原理是什么

```css
采用的是相邻边框均分的原理。讲元素的宽高都设置为0，只设置border的值，把任意三边隐藏掉(颜色都设置为treansparent)，剩下的就是一个三角形。
#demo{
    width:0;
    height:0;
    border:20px solid;
    border-color:transparent transparent transparent red;
}
```

## 一个满屏字布局应该如何设置

```
简单的方式：
	上边的div宽为100%
	下面两个div的宽分别为50%
	然后用float或者inline使其不换行即可
```

## CSS多列等高如何实现？

```
1.margin-bottom 与 padding-bottom正负值相抵的方式 讲内边框的内容撑大然后通过外边框缩小两个div的距离，对此页面布局不会有任何影响，另外父元素要设置overflow:hidden 把子元素多出来的部分隐藏掉
2.模拟table布局， 利用table-cell所有单元格的高度都是相等的特征，来实现多列等高。
3.利用flex的伸缩项目默认拉升为父元素的高度，同样可以实现等高的效果，在pc端上兼容性不是很好。(flex布局中项目align-items属性默认为stretch,如果项目我i设置高度或者设为auto，讲沾满整个容器的高度的特性，来实现多列等高)
```

## 经常遇到的浏览器的兼容性有哪些？原因，解决方法是什么，常用hack的技巧?

```
1.png24位的图片在ie6浏览器上出现背景
解决方案：做成png8，也可以引入一些脚本处理。
2.浏览器默认的margin，padding的不同
解决方案；加一个全局 *{margin:0,padding0}来统一。
3.IE下，可以使用获取常规属性的方法来获取自定义属性，也可以使用getArrtibute()获取自定义属性，在firefox下，只能使用getArrtibute()获取自定义属性。
解决方案：统一使用getArrtubute()获取自定义属性。
```

## li与li之间有看不见的空白间隔是什么原因引起的?有什么解决办法？

```
浏览器会把inline元素间的空白字符(空格，换行，tab)，渲染成一个空格，而为了美观，我们通常是一个<li>放一行 这导致<li>换行后产生换行字符，它变成一个空格，占用了一个字符。
解决办法：
1.将<li>设置float：left，不足：有些容器是不能设置浮动，如左右切换的焦点图等。
2.将所有的<li>写在一行。不足：代码不美观。
3.将所有<ul>内的字符尺寸直接设置为0，即font-size:0,不足：需要额外重新设置其他字符尺寸，且在safari浏览器依旧会出现这个问题
```

## 为什么要初始化css样式？

```
-因为浏览器的兼容性问题，不同浏览器对标签的默认值是不同的，如果没有对css初始化往往会出现浏览器之间页面显示差异。
-当然，初始化样式会对seo有一定影响。但是鱼和熊掌不可兼得，但力求影响最小的情况下进行初始化。
最简单的初始化方式就是 *{margin:0;padding:0;}(强烈不建议)
```

## 什么是包含块，对于包含块的理解？

```
包含块：就是用来元素计算和定位的一个框。(一个元素的盒子的尺寸和位置根据一个准确的矩形决定，这个矩形叫做包含块)
1.根元素(很多场景下看成<html>)被称为"初始包含块"，其尺寸等于用户可视窗口的大小。
2.对于其他元素，如果该元素的positon是relative或者static，则"包含块"由其最近祖先的content-box边界形成。
3.position：fixed，则"包含块"是初始包含块
4.position：absolute，则"包含块"由最近的position不为static的祖先元素创建，具体方式如下：
如果该祖先元素是inline元素，则规则略复杂：
-假定给内联元素的前后各生成一个宽度为0的内联盒子(inlinebox)，则两个内联盒子的paddingbox外面的包围盒就是内联元素的包含块
-如果改内联元素被跨行分割，那么"包含块"未定义，根据浏览器自由发挥。
否则包含块就就是父级元素的paddingbox边界形成
如果没有符合条件的祖先元素,则"包含块"是"初始化包含块"
```

## display:none与visibility:hidden的区别

```
共同点: 它们都可以使元素不可见
不同点: 
1. display:none 会让元素完全在渲染树中消失，不渲染的时候不占据任何空间。visibility:hidden 不会让元素从渲染树中消失，不渲染时元素继续占据空间，只是内容不可见
2. display:none 是非继承属性,子孙节点消失是因为元素从渲染树中消失造成，通过修改子孙节点属性无法显示；而visibility:hidden是继承属性,子孙节点消失由于继承了hidden，通过设置visibility:visible;可以让子孙节点显示
```

## CSS里的visibility属性中有个collapse属性值是干嘛用的？在不同浏览器下以后有什么区别？

```
1.对于一般的元素,它的表现跟visibility:hidden。是一样的。元素是不可见的，但此时仍占用页面空间。
2.但例外的是，如果这个元素是table相关的元素，例如table行，tablegroup，table列，tablecolumngroup，它的表现和display:none一样，也就是说，它们占用的空间也会释放。
在不同浏览器下的区别:
	在谷歌浏览器中，使用collapse值和hidden没有任何区别。
	在火狐和ie11里，使用collapse值的效果就如它的字面意思:table的行会消失，它额下面一行会自动补充他的位置。
```

## width:auto和width:100%的区别

```
一般而言
width:100% 会使元素宽度等于父元素contentbox宽度
width:auto 会使元素撑满这个父元素，margin padding border content区域会自动分配水平空间。
```

## 绝对定位元素与非绝对定位元素的百分比计算的区别

```
绝对定位的宽高百分比是相对于临近的position不为static的祖先元素的paddingbox来计算
相对定位的宽高百分比是相对于父元素的contentbox来计算。
```

## 简单介绍使用图片base64编码的优点和缺点

```
base64编码是一种图片处理格式，通过特定的算法可以将图片编码成一长串字符串，在页面显示的时候，可以用该字符串来代替图片的url属性。
使用base64的优点是：
1.减少一个图片的http请求
使用base64的缺点是：
1.根据base64编码原理，编码后的大小比原来大1/3，如果把大图片编码到html/css中，不仅会造成文件体积的增加，影响文件的加载速度，还会增加浏览器对html/css文件渲染解析的时间
2.使用base64无法进行直接缓存，要缓存只能缓存base64的文件，比如html或者css，这相比于直接缓存图片的效果要差的多。
3.兼容性的问题。ie8以前的浏览器不支持
一般小图片可以使用base64图片引入
```

## 'display'、'positon'和'float'的相互关系

```
1.首先判断display是否未none,如果为none,则positon和float的属性值不会影响元素最后的表现。
2.然后判断position的值是否为absolute或者fixed,如果是则float属性失效，并且display的值应该被设置为table或者block,具体转换需要看初始转换值。
3.如果postition的值不是absolute或者fixed,则判断float的值是否为none，如果不为none，则display的值会被设置成block或者table。(如果position的值为relative的时候并且float存在，则relative相对于浮动后的最终位置定位)
4.如果float为none时，判断元素是否为根元素，如果是根元素则display属性按照上面规则转换，如果不是，则保持display属性值不变。

总的来说，可以把它堪称一个类似于优先级的机制,"position:absolute"和"position:fixed"的优先级最高，有它存在的时候，浮动不起来，"display"的值也需要调整。其次，float特效的值不是"none"的时候或者它是根元素的时候，调整display的值。最后，非根元素，并且非浮动元素，并且非绝对定位的元素，'display'特性值同设置值。 
```

## margin重叠问题的理解。

```
块级元素的上外边框(margin-top)与下边框(margin-bottom)有时会合并为单个边框，这样的现象称为"margin合并"。
产生折叠的必备条件:margin必须是邻接的!
margin重叠指的是在垂直方向上，两个相邻元素margin重叠问题。
一般来说分为四种情形:
第一种 是相邻兄弟元素的margin-top和margin-buttom的值发出重叠。这种情况下我们可以通过设置其中一个元素为BFC来解决。
第二种 情况是父元素的margin-top和子元素margin-top发生重叠。它们发生重叠时因为它们时相邻的，所以我们可以通过这一点来解决这个问题。我们可以为父元素设置border-top,padding-top来分割它们，当然我们也可以设置父元素为BFC来解决这个问题。
第三种 是高度为auto的父元素的margin-bottom和子元素的margin-bottom的发生重叠。它们发生重叠一是因为父元素高度不确定，二是因为相邻。因此我们可以为父元素设置border-bottom和padding-bottom来分隔它们，也可以为父元素设置一个高度,max-height和min-height也能顺利解决这个问题。当然将父元素设置为BFC更简单。
第四种 是没有内容的元素，自身的margin-top和margin-bottom元素发生重叠。我们可以通过设置其border，padding或者高度来解决。
```

## 对BFC规范的理解(块级格式化上下文)？

```
块级严格执行上下文(BlockFormattingContext,BFC)，一个元素形成BFC之后，那么他内部元素产生的布局不会影响外部元素，外部元素的产生的布局也不会影响内部元素。一个BFC就像一个隔离区域，其他区域互不影响。
一般来说根元素就是一个BFC区域，浮动和绝对定位也能形成一个BFC,display的值为line-block,flex这些属性时也会创建BFC。还有就是元素的overflow的值不为visible时都会创建BFC。
```

## IFC是什么

```
IFC指的是行级格式化上下文，它有这样的布局规则:
1.行级上下文的内联盒子会在水平方向上，一个接一个地放置。
2.当一行不够的时候自动切换到下一行。
3.行级上下文的高度由内部最高的内联盒子的最高高度决定。
```

## 请解释一下为什么要清除浮动？清除浮动的方式？

```
浮动元素可以左右浮动，直到遇到另一个浮动元素或者遇到它的外边缘的包含框。浮动框不属于文档流中的普通流。当元素浮动之后，不会影响块级元素的布局，只会影响内联元素的布局。此时文档流中的普通流表现的该浮动库不存在一样的布局模式。当包含框的高度小于浮动框的时候，此时就会出现"高度塌陷"。
清除浮动是为了清除使用浮动元素产生的影响。浮动的元素，高度塌陷，而高度塌陷会使我们后面的布局不能正常显示。
清除浮动的方式：
	 1.父 添加 (设置BFC)
     overflow: hidden;
     overflow:auto;
     2.父后面添加after (使用clear both属性清除浮动)
     content='';
     display=black;
     clear=both;
```

## 使用clear属性清除浮动的原理？

```
使用clear属性清除浮动，其语法如下：
clear：none|left|right|both
如果单看字面意思，clear:left应该是“清除左浮动”，clear:right应该是“清除右浮动”的意思，实际上，这种解释是有问题的，因为浮动一直还在 ，并没有清除。
官方对clear属性的解释使："元素盒子的边不能与前面的浮动元素相邻"，我们对元素设置clear属性是为了避免浮动元素产生的影响，而不是清除浮动。
还需要还需要主要的是clear属性指的是元素盒子的边不能和前面的浮动元素相邻，注意这里"前面的"3个字，也就是clear属性对"后面的"浮动元素是不闻不问的。考虑到float属性要么是left要么是right，不能同时存在，同时由于clear属性对"后面的"浮动元素不闻不问。因此clear：left有效的时候,clear:right必定无效，也就是此时clear:left等同于设置了clear:both。同样的clear：right有效的时候也等同于设置clear:both。由此可见，clear:left和clear:right这两个声明并没有任何使用价值，至少在css世界中不是如此，直接使用clear:both吧。
一般使用伪类元素的方式清除浮动
.clear ::after{
	content:'';
	display:table;// 也可以是block 或者是 list-item
	clear:both;
}
clear属性只有是块级元素的时候才能生效，而::after等伪类元素默认为内联元素，这就是借助伪元素清除浮动影响时需要设置display属性值的原因。
```

## zoom:1的清除浮动原理？

```
清除浮动，触发hasLayout；
zoom属性是ie浏览器的专有属性，它可以设置或检索对象的缩放比例。解决ie下比较奇葩的bug。譬如外边距(margin)重叠,清除浮动，触发ie的haslayout属性等。
来龙去脉大概如下:
当设置了zoom的值之后，所设置的元素就会扩大或者缩小，高度宽度就会重新计算了。这里一旦改变zoom值时其实也会发生重新渲染，运用这个原理，也就解决了ie下 子元素浮动时父元素不随着自动扩大的问题。

zoom 是ie浏览器的专有属性，火狐或者老版本的webkit核心的浏览器都不支持此属性。然而，zoom 现在已经出现在css3.0规范草案中。
目前非ie由于不支持这个属性，它们又是通过什么属性进行元素缩放呢？通过通过css3中的动画属性scale进行缩放。
```

## 移动端的布局用过媒体查询吗？

```
假设你现在正用一台显示设备来阅读这篇文章，同时你也想把它投影到屏幕上，或者打印出来，而显示设备、屏幕投影和打印等这些媒介都有自己的特点，css就是为文档提供在不同媒介上显示的适配方法。
当媒体查询为真时，相关的样式表或者样式规则会按照正常的规则被应用。当媒体查询为假，标签上带有媒体查询的样式表仍然会被下载(只不过不会被应用)。
包含了一个媒体类型和至少一个使用宽度、高度和颜色等媒体属性来限制样式范围的表达式。css3加入的媒体查询使的无需修改内容便使样式应用与某些特定的设备范围。
```

## 使用css预处理器吗？喜欢哪个？

```
SASS(SASS,LESS没有本质区别)
```

## CSS优化、提高性能的方法有哪些？

```
加载性能：
	1.css压缩：将写好的css进行打包压缩，可以减少很多体积。
	2.减少使用@import,而建议使用link。因为后者在页面加载的时一起加载，前者是等待页面完之后再加载。
选择器性能:
	1.关键选择器。选择器的最后面的部分为关键选择器(即用来匹配目标元素的部分)。CSS选择符是从右到左进行匹配的。当使用后代选择器的时候，浏览器会遍历所有子元素来缺点是否是指定元素等
	2.避免使用通配规则，如*{}计算次数惊人！只对需要用到的元素进行选择。
	3.尽量少的去对标签进行选择，使用class。
	4.了解哪些属性是可以通过继承而来的，然后避免重复定义。
渲染性能：
	1.慎重使用高性能属性:浮动，定位。
	2.尽量减少页面重排、重绘。
	3.属性值为0时，不加单位
	4.不滥用web字体。对于中文网站来说webfonts可能很模式，国外却很流行。webfonts通常体积庞大，并且一些浏览器在下载webfonts时会阻塞页面渲染损伤性能。
可维护性、健壮性：
	1.将相同属性的样式抽离出来，整合并通过class在页面中使用，提高css可维护性。
	2.样式和内容分离:将css代码定义到外部css中。
```

## 浏览器是怎么解析css选择器的？

```
样式系统从关键选择器开始匹配，然后左移查到规则选择器的祖先元素。只要选择器的子树一直在工作，样式系统就会持续左移，直到和规则匹配，或者是因为不匹配而放弃规则。

按照从上到下，从右到左的顺序解析。
.list a {color:blue;}
先解析到 a 标签，并将页面上所有 a 标签的字体颜色都按照 color:blue 进行渲染（蓝色），再解析到 .list ，将页面上所有 .list 类目下的 a 标签的字体渲染成蓝色。
因为只要发现最右边选择器不匹配，就可以直接舍弃了，避免了无效匹配。
```

## 在网页中应该使用奇数还是偶数的字体？为什么呢？

```
1.偶数字号相对更加容易和web设定的其他部分构成比例关系。比如：当我用了14px的正文字体，我可能会在一些地方使用14*0.5=7px的marigin，在另一些地方用14*1.5=21的标题字体。
2.浏览器的缘故。低版本的浏览器会把奇数字体强制转换成偶数。
3.系统差别，早期的Windows里，中易宋体点阵只有12和14、15、16px，唯独缺少13px。
```

## margin和padding分别适合什么场景的使用？

```
margin是用来隔开元素与元素之间的间隔。padding是用于隔开元素和内容的间隔。
margin用于布局分开元素，是元素和元素互不相干。
padding用于元素和内容的间隔，让内容(文字)与(包裹)元素之间有一段距离.

何时应当使用margin:
	1.需要在border外侧添加空白的时候。
	2.空白处不需要背景色的时候。
	3.上下相连的两个盒子之间的空白，需要相互抵消。比如15px+20px的margin，将得到20px的空白。
何时应当使用padding：
	1.需要在border内则添加空白。
	2.空白处需要背景色。
	3.上下相连的两个盒子之间的空白，等于两者之和。如15px+20px的padding，将得到35px的空白
```

## 抽离样式模板怎么写，说出思路

```
我把常用的css样式单独做成css文件...通用的和业务相关的分离出来，通用的做成样式模块共享，业务相关的，放进业务相关的库里面做成对应功能的模块
```

## 简单说一下css3的all属性

```
all属性实际上是所有css属性的缩写，表示，所有的css属性都怎样怎样，但是，不包含unicode-bidi和dirction unicode-bidi (属性设置文本的方向。)
initial是初始值的意思，也就是该元素除了unicode-bidi和direction以外的css属性使用属性默认初始值。
inherit是继承的意思，也就是该元素除了unicode-bidi和direction以外的css属性都继承父元素的属性值。
unset是取消设置的意思，也就是当前元素浏览器或用户设置的css忽略，然后如果是具有继承特征的css，如color，则使用默认值，如果是没有继承特效的css属性，如bacjground-color，则使用初始值。
```

## 为什么不建议使用通配符初始化css样式

```
虽然写法简单，但是是通配符，需要把所有的便签都遍历一遍，当网站较打时，样式比较多。这样写就大大的加强了网站运行的负载，会使网站加载的时候需要很长一段时间，因此一个大型的网站都会有分层次的一套初始化样式。
处于性能的考虑，并不是所有标签都会有padding和margin，因此对常见的具有默认指的margin和padding元素初始化即可，并不需要使用通配符*来初始化。
```

## absolute的containingblock(包含块)计算方式和正常流有什么不同？

```
1.内联元素也可以作为"包含块"所在的元素。
2."包含块"所在元素不是父级元素，而是最近的position不为static的祖先元素或根元素。
3.边界不是paddingbox而不是contentbox
```

## 对于hasLayout的理解

```
hasLayout使ie特有的一个属性。很多ie下的cssbug都与其息息相关。在ie中，一个元素要么自己对自己的内容进行计算大小和定位,要么依靠父元素来计算尺寸和组织内容。当一个元素的haslayout属性值为true时，他负责对自己和可能的子孙进行尺寸计算的定位。虽然这意味着这个元素需要花更多的代价来维护自身和里面的内容，而不是依赖于祖先元素来完成这些工作。
```

## 元素竖向的百分比设定是相对于容器的高度吗？

```
如果是height的话，是相对于包含块的高度。
如果是padding和margin竖直方向的属性则是依照包含块的宽度。
```

## 全局滚动的原理是什么？用到了css的哪些属性？

```
原理：有点类似于轮播，整体的元素一直排列下去，假定有5个需要展示的全局页面，那么高度是500%，只是展示100%,容器及容器内的页面取当前可视区高度，同时容器的父级元素要设置overflow:hidden，通过更改容器可视区的位置来实现全屏滚动效果。主要是鼠标事件，页面通过css的动画效果，进行移动。

overflow:hidden transition: all 1000ms ease
```

## 什么是响应式设计？响应式设计的基本原理是什么？如果兼容低版本的IE？

```
响应式设计是一个网站能兼容多个终端，而不是为每个终端都写一个版本。基本原理就是通过媒体查询检测到不同的设备屏幕尺寸来做处理。页面头部必须有meta声明的viewport
```

## 视差滚动效果，如何给每页做不同的动画？（回到顶部，向下滑动要再次出现，和只出现一次分别怎么做？）

```
视差滚动是多层背景以不同的是速度进行移动，形成立体效果，带来非常不错的视觉体验
```

## 如何修改chrome记住密码后自动填充表单的黄色背景？

```
chrome表单自动填充后，input文本框的背景色会变成黄色的，通过审查元素可以看到这是由于chrome会默认给自动填充的input表单加上input:-webkit-autofill私有属性，然后对其赋予以下样式：
{
background-color:rgb(250,255,189)!important;
background-image:none!important; 
color:rgb(0,0,0)!important; 
}
对chrome默认定义的background-color，background-image，color使用important是不能提高其优 先级的，但是 其他属性可使用。 使用足够大的纯色内阴影来覆盖input输入框的黄色背景，处理如下
详细资料可以参考：
input:-webkit-autofill,textarea:-webkit-autofill,select:-webkit-autofill
{ -webkit-box-shadow:000px1000pxwhiteinset; border:1pxsolid#CCC!important; }
```

## 怎么让Chrome支持小于12px的文字？

```
在谷歌下css设置字体大小为12px及一下时，显示的一样的大小，都是默认12px。
解决办法：
	1.使用css3中的transform缩放属性-webkit-transform:scale(0.5);注意-webkit-transform:scale(0.75);收缩的是整个元素的大小，这时候，如果是内联元素，必须要将内联元素转换成块元素，可以使用display:block/inline-block
	2.使用图片:如果是固定内容不变的情况下，使用将小于12px文字内容切出做的图片，这样不影响兼容也不影响美观
	3.可以使用webkit的内核的-webkit-text-size-adjust的私有css属性来解决，只要加了-webkit-text-size-adjust:none;字体大小就不受限制了。但是chrome更新到27版本之后就不可以使用了。
```

## 让页面里的字体变清晰，变细用css怎么做？

```
webkit内核私有属性：-webkit-font-smoothing，用于字体抗锯齿，使用后字体看起来会更加清晰舒服。只在Macos中生效
```

## font-style属性中italic和oblique的区别？

```
italic和oblique这两个关键字都表示"斜体"的意思。
它们的区别在于，italic是使用当前字体的倾斜字体，而oblique是单纯将文字倾斜。如果当前字体没有对应的倾斜字体，则退而求其次，解析为oblique，也就是单纯字体倾斜。
可以理解成 italic 是使用文字的斜体，oblique 是让没有斜体属性的文字倾斜！
```

## 设备像素、css像素、设备独立像素、dpr、ppi之间的区别？

```
设备像素指的是物理像素，一般手机的分辨率就是设备像素，一个设备的设备像素是不可变的。
CSS像素和设备像素是等价的，不管在何时分辨率的设备上，css像素大小应该是一致的，css像素是一个相对单位，他是相对于设备像素的，一个css像素的大小取决于页面缩放程度和dpr的大小。
dpr指的是设备像素(物理像素)和设备独立像素(逻辑像素)的比值,一般的pc屏幕，dpr=1。在iphone4时，苹果退出了retina屏幕，它的dpr为2，屏幕的缩放会改变dpr的值。

ppi指的是每英寸的物理像素的密度，ppi越大，屏幕的分辨率越大
```

## 如何去除inline-block元素间间距？

```
使用margin为负值,使用font-size:0,letter-spacing,word-spacing
```

## 如果需要手动写动画，你认为最小时间间隔是多少，为什么

```
多数显示器默认频率是60HZ,即1秒刷新60次，所以理论上最小间隔为1/60*1000ms=16.7ms
```

## layoutviewport,visualviewport和idealviewport的区别？

```
移动端一共需要理解三个viewport的概念的理解。
第一个视口是布局视口,在移动端显示页面的时,由于移动端的屏幕尺寸比较小，如果网页使用移动端的屏幕尺寸进行布局的话，那么整个页面都会使用显示错乱。所以移动端浏览器提供了一个layoutviewsport布局视口的概念，使用这个视口来对网页进行布局展示，一般layoutviewsport的大小为980px,因此页面布局不会有太大的变化，我们可以通过拖动和缩放来查看这个页面。
第二个视口是视觉视口,visualviewsport指的是移动设备上我们可见的区域的视口大小，一般为屏幕的分辨率的大小,visualviewport和layoutviewsport的关系，就像是我们通过窗户看外面的风景，视觉视口就是窗户，而外面的风景就是布局视口中的网页内容。
第三个视口是理想视口，由于layoutviewsport一般比visualviewsport要大，所以想要看到整个页面就必须通过缩放和拖动才能实现。所以又提出了idealviewsport的概念，idealviewsport其实就是通过修改layoutviewsport的大小，让它等于设备的宽度，这个宽度可以理解为设备独立像素，因此根据idealviewsport设计的页面，在不同分辨率的屏幕下，显示应该相同。
```

## position:fixed;在android下无效怎么处理？

```
因为移动端浏览器的默认视口为layoutviewsport。在移动端显示时，因为layoutviewsport的宽度大于移动端屏幕的宽度，所以页面会出现滚动条左右移动，fixed的元素相对layoutviewsport来固定元素的，而不是移动端屏幕来固定位置的，所以会出现感觉fixed无效的情况。
如果想实现fixed相对于屏幕的固定效果，我们需要将layoutviewsport改为ideaviewsport，可以如下设置:
<metaname="viewport"content="width=device-width,initial-scale=1.0,maximum- scale=1.0,minimum-sca le=1.0,user-scalable=no"/>
```

## overflow：scroll 时不能平滑滚动的问题怎么处理？

```
-webkit-overflow-scroll:touch ;是因为这段代码启动了硬件加速特性,所以滑动很流畅
```

## 有一个高度自适应的div，里面有两个div，一个高度为100px，希望另外一个填满剩下的高度

```
1.外层div使用position:relatvie;高度要求自适应的div使用positon:absolute;top:100px;left:0;right:0;bottom:0;
2.使用flex布局，设置flex-direction(主轴方向为竖轴),第二个div设置flex=1
```

## png，jpg，gif这些图片格式解释一下，分别什么时候用，有没有了解过webp？

```
1.BMP格式,它是无损的，支持索引色和直接色的点阵图。由于它基本上没有进行压缩，因此它的文件体积一般比较大。
2.GIF格式，它是无损压缩的使用索引色的点阵图。由于使用了LZW压缩方法，因此文件的体积很小，并且GIF还支持动画和透明度。但因为它使用的是索引色，所以它适用于一些对颜色要求不高且文件体积小的场景。
3.JPEG格式，它是有损压缩的使用直接色的点阵图。由于使用了直接色，色彩较为丰富，一般适合用于存储图片。单由于使用的是直接色，可能文件的体积相对于GIF格式来说更大。
4.PNG-8格式，它是无损压缩的使用索引色的点阵图。他是GIF的一种很好的替代格式，它也支持透明度的调整，并且文件体积相对于GIF格式更小。一般来说如果不是需要动画的情况，我们都可以使用PNG-8格式代替GIF格式。
5.PNG-24格式，它是无损压缩的使用直接色的点阵图。PNG-24的优点是它使用了压缩算法，所以它的体积比BMP格式的文件要小得多，但是相对于其他的几种格式，还是要大一些。
6.svg格式，它是矢量图，它记录的图片的绘制方式，因此对矢量图进行放大和缩小不会产生锯齿和失真。它一般适合用于指定一些网站的logo或者图标之类的图片。地图
7.webp格式，它是支持有损和无损两种压缩方式的使用直接色的点阵图。使用webp格式的最大的优点是，在相同质量文件小，它拥有更小的文件体积。因此它非常适合于网络图片的传输，因为图片体积的减少，意味着请求时间的减少，这样会提高用户的体验。这是谷歌开发的一种图片格式，目前在兼容性上还不是很好
```

## 浏览器如何判断是否支持webp格式图片

```
1.宽高判断法。通过创建image对象，将其src属性设置为webp格式的图片。然后再onload事件中获取图片的宽高，如果能够获取，则说明浏览器支持webp格式图片。如果不能获取或者触发了onerror函数，那么就说明浏览器不支持webp格式的图片。
2.canvas判断方法。我们可以动态的创建一个canvas对象，通过canvas的toDataURL将设置为webp格式，然后判断返回值中是否含有image/webp字段。如果包含则说明支持webp，反之则不支持。
```

## svg和canvas的区别

```
语言:canvas是使用javascript语言来描绘图片,svg是使用xml语言进行描绘图片。
表现:canvas依赖像素，放大会失真,svg不依赖像素,放大不会失真
应用场景:canvas应用于游戏,svg运用于一些网站的logo或者图标之类|地图。
```

## 什么是cookie隔离？(请求资源的时候不要让它带cookie怎么做)

```
网站向服务器请求的时候，会自动带上cookie这样增加表头信息量，使请求变慢。
如果静态文件都放在主域名下，那静态文件请求的时候都带有的cookie的数据提交给server的，非常浪费流量，所以不如隔离开，静态资源放到CDN。
因为cookie有域的性质，因此不能跨域提交请求，故使用非域名的时候，请求头中就不
会带有cookie数据，这样可以降低请求头的大小，降低请求时间，从而达到降低整体请求延时的目的。
同时这种方式不会将cookie传入webServer，也减少了webServer对cookie的处理分析环节，提高了webserver的http请求的解析速度。
```

## style标签写在body后和body前有什么区别

```
页面加载是自上向下当然是先加载样式，写在boby标签后由于浏览器逐步对html进行解析，当解析到写在尾部的样式表(style标签或者外联)会导致页面暂停之前的渲染，等到加载且解析样式表完成之后重新渲染，在widows下ie可能会出现FOUC现象(即样式失效导致页面闪烁问题)。
```

## 什么是CSS预处理器/后处理器？

```
CSS是一种专门的编程语言，进行web页面设置，然后再编译成正常的css文件。
常用的css预处理器有 less Sass，增强了css代码的复用性，极大的提高了工作效率。
css后处理器是对css进行处理，并最终形成css预处理器，是广义上的css预处理器。
```

## 阐述一下CSS Sprites

```
简称css精灵,将一个页面的所有涉及的图片整合到一个大的图片中去，然后利用background-image,background-repeat,background-position进行背景定位。利用css spties能很好的减少http请求,从而很好的提高页面的性能。CSS Sprites能减少图片的字节。
优点：
	减少http请求数,极大地提高了页面加载速度
	增加图片信息重复,提高压缩比,减少图片大小。
	更换风格比较简单,只需在一张或者多张图片上修改颜色或者样式即可实现
缺点：
	图片合并比较麻烦。
	维护麻烦，修改一个图片可能需要重新布局整个图片的样式

```

## 使用rem布局的优缺点

```
优点:
	在屏幕分辨率千差万别的时代，只要将rem和屏幕分辨率关联起来就可以实现页面的整体缩放，使得在设备上的展示都统一起来。而且现在的浏览器都支持rem了，兼容性非常好。
缺点:
	1.在奇葩的dpr设备上表现效果不太好，比如华为的高端机型用rem布局就会出现错乱。
	2.使用iframe引用也会出现问题。
	3.rem在多屏幕适配尺寸上与当前两大平台的设置哲学不一致，即大屏幕的出现是为了看的又大又清晰，还是为了看的更多的问题
```

## 画一条0.5px的线

```
采用viewport的方式
采用border-image的方式
采用trensform:scale()的方式
```

## transition和animation的区别

```
大部分都是相同，都是随着时间改变元素的属性值，他们的主要区别是transition需要触发一个事件才能改变属性，而animation不需要触发任何事件就可以执行。transition为两帧，从from...to..，而animation可以一帧一帧的 通过keyframes
```

## 什么是首选最小宽度？

```
指的是元素最适合的最小宽度。
中文最小宽度为每个文字的宽度。
西方文字最小宽度是由特定的连续英文字符单元决定。并不是所有的英文字符都会组成连续单元,一般会终止于空格、短横线、问好以及其他非英文字符。
如果想让英文字符和中文一样，每一个字符都用最小宽度单元，可以使用css中word-break:break-all。
```

## 为什么height:100%会失效？

```
对于普通的文档流,百分比高度要想起作用，其父级必须有一个生效的高度值。
原因是如果包含块的高度没有显示指定(高度由内容决定),并且该元素不是绝对定位，则计算值为auto,因为解释成auto所以无法参与计算。
使用绝对定位的元素也有计算值，即使祖先元素的height计算为auto也是如此
```

## min-width/max-width和min-height/max-height属性间的覆盖规则

```
1.max-width会覆盖width，即使width是行内样式或者设置了!important。
2.min-width会覆盖width，此规则发生在min-width和max-width冲突的时候
```

## 内联盒子的基本概念

```
1.内容区域。内容区域是一种围绕文字看不见的盒子，其大小仅受字符本身特性控制，本质上是一个字符盒子。但是有些元素，如图片这样的替换元素，没有字符，因此这些元素的内容区域可以看成元素自身。
2.内联盒子。"内联盒子"不会让内容成块显示，而是排成一行，这里的"内联盒子"实际指的是元素的"外在盒子"，用来决定元素是块级还是内联。该盒子又分为"内联盒子"和"匿名内联盒子"两类。
3.行框盒子，每一行就是一个"行框盒子"(实线框标准),每个"行框盒子"又是由一个个"内联盒子"组成。
4.包含盒子，由一行一行的"行框盒子"组成。
```

## 什么是幽灵空白节点

```
幽灵空白节点是内联盒子模型中一个非常重要的概念。具体指的是:在html5文档声明中，内联元素的所有解析和渲染如同每个行框盒子的前面有一个"空白节点"一样,这个"空白节点"永远透明，不占据任何宽度，看不见也无法通过脚本获取，就好像幽灵一样，但又确确实实的存在，表现的如同文本节点一样，因此，我称之为"幽灵空白节点"。
例如 <div ><span></span></div>
这个时候span里面什么也没有，我们确可以看到div有高度，所以我们认为在span前面还有一个宽度为的字符称其了这个div
```

## 什么是替换元素？

```
通过修改某个属性值所呈现的元素内容被替换的元素就称为"替换元素"。因此，<img>,<object>,<video>,<iframe>,或者表单元素<textarea>和<input>和<select>都是经典的替换元素。替换元素除了内容可替换这一特以外，还有以下一些特性。
1.内容的外观不受页面的css影响，用专业的话讲样式表现在css作用域之外。如何更改替换元素本身的外观西药类似于appearance属性，或者浏览器自身暴露一些样式接口。
2.有自己的尺寸。在web中，很多替换元素在没有明确尺寸指定下，其默认的尺寸(不包含边框)是300像素X150像素，如<video>,<iframe>或者<canvas>等，也有少部分替换元素为0像素，如<img>图片，而表单元素的替换元素的尺寸与浏览器有关，没有明显规律。
3.在很多css属性上有自己的一套表现规则。比如具有代表性的就是vertical-align属性，对于替换元素和非替换元素，vertical-align属性值的解释是不一样的。比如说vertical-align的默认值是baseline，很简单的属性值，基线之意，被定义为字符x的下边缘，而替换元素的基线却被硬生生定义成了元素的下边缘。
4.所有的替换元素都是内联水平元素，也就是替换元素和替换元素，替换元素和文字都可以在一行显示。但是替换元素的默认值的display值却是不一样的，有的是inline，有的是inline-block。
```

## 替换内容的计算规则？

```
替换元素的尺寸从内到外分为3类:固有尺寸，HTML尺寸、CSS尺寸。
1.固有尺寸指的是替换内容原本的尺寸，例如，图片，视频作为一个独立文件存在的时候，都是有着自己的宽度和高度。
2.HTML尺寸只能通过HTML原生属性改变，这些HTML原生属性包括<img>的width和height属性，input的size属性，texarea的cols和rews属性等。
3.css尺寸特指通过css的width和height或者max-width/min-width和max-height/min-height设置的尺寸，对应盒子尺寸中的contentbox。
这三层结构的计算规则具体规则如下:
1.如果没有css尺寸和html尺寸，则使用固有尺寸作为最终的宽高。
2.如果没有css尺寸，则使用HTML尺寸作为最终的宽高。
3.如果有css尺寸，则尺寸由CSS属性决定。
4.如果"固有尺寸"含有固有宽高比例，同时仅设置了高度或者仅设置宽度，则元素依然按照固有的宽高比例显示。
5.如果上面的条件都不符合，则最终宽度表现为300像素，高度为150像素。
6.内联替换元素和块级替换元素是使用同一套尺寸计算规则。
```

## content与替换元素的关系？

```
content属性生成的对象是"匿名替换元素"。
1.我们使用content生成文本是无法选中的，是无法复制，好像设置了userselect：none声明一般，但是普通元素的文本可以轻松的被选中。同时content生成的文本无法被屏幕阅读设备读取，也无法被搜索引擎抓取，因此，千万不要自以为是的把重要的文本信息使用content属性生成，因为这对可访问性和seo都很不友好。
2.content生成的内容不能左右:empty伪类 E:empty 的含义：——匹配元素内部为空（没有内容）的元素
3.content动态生成值无法获取。
```

## margin:auto的填充规则

```
margin:auto可不是摆设，是具有强烈的计算意味的关键字，是用来计算元素对应方向上应该获得的剩余间隔大小，但是触发margin：auto计算有一个前提条件就是width和height为auto时，元素时具有对应方向的自动填充特性的。
1.如果一侧为定值，一侧为auto，则auto为剩余空间。
2.如果两侧都为auto，则平分剩余空间
```

## margin无效的情形

```
1.display为inline的非替换元素的垂直margin是无效的。对于内联替换元素垂直的margin是有效的，并且没有margin重叠问题。
2.表格中<tr>和<td>元素或者设置display为table-cell或则table-row的margin值都是无效的。
3.绝对定位的非定位方向的margin值无效。
4.定高容器的子元素margin-bottom和定宽容器的子元素margin-right的定位是无效的。
```

## border的特殊性？

```
1.border-width不支持百分比。
2.border-style默认为none。
3.border-sytle:double的表现规则:双线宽度永远相等，中间间隔+-1。
4.border-color默认颜色为color色值.
5.默认background背景图片是相对于paddingbox定位。
```

## 什么是基线和x-height？

```
字符x的下边缘就是我们的基线。
x-height指的就是小写字母x的高度，术语描述就是基线和等分线之间的距离。在css世界中middle指的是基线往上1/2 x-height高度。我们可以近似理解为字母x交叉点的那个位置。
ex是css中的相对单位，指的是小写字母x的高度，就是指x-height。ex的价值在于其副业上不受字体和字号影响的内联元素的垂直居中对齐效果。内联元素默认是基线对齐的。而基线就是x的底部，而1ex就是一个x的高度。
```

## line-height的特殊性？

```
1.对于非替换元素的纯内联元素，其可视高度完全由line-height决定。对于文本这样的纯内联元素，line-height就是高度计算的基石，用专业的说法就是制定了用来计算行款盒子的基础高度。
2.内联元素的高度有固定元素和非固定元素组成，这里的不固定部分就是这里的"行距"。换句话说line-height之所以起作用，就是通过改变"行距"来实现了。在css中，"行距"分散在当前文字的上方和下风，也就是即使是第一行文字，其上方也是有"行距"的，只不过这个"行距"的高度仅仅是完整"行距"高度的一半，因此，也称为"半行距"。
3.行距=line-height - font-size。
4.border以及line-height等传统css属性并没有小数像素的概念，如果标注的是文字上边距，则向下取整。如果是文字下边距，则向上取整。
5.对于纯文本元素，line-height直接决定了最终高度。但是，如果同时有替换高度，则line-height决定了只能决定最小高度。
6.对于块级元素，line-height对其本身没有任何作用，我们平时改变line-height，块级元素的高度跟着变化实际上是通过改变块级元素里面内联级别元素占据的高度来实现的。
7.无论内联元素line-height如何设置，最终父级元素的高度都是由数值最大的决定的。
8.只要有"内联盒子"就一定有行框盒子，就是每一个行狂盒子外面包裹了一层看不见的盒子。在每个"内联盒子"的前面都有一个宽度为0的具有元素的字体和行高属性的看不见的"幽灵空白节点"。
```

## vertical-align的特殊性

```
1.vertical-align的默认值是baseline，即基线对齐，而基线的定义是字符x的下边缘。因此，内联盒子默认都是沿着字母x的下边缘对齐。对于图片等替换元素，往往使用元素本身下边缘作为基线。:一个inline-block元素，如果里面没有内联元素，或者overflow不是visible，则该元素的基线就是margin边缘；否则基线就是元素里面最后一行内联元素的基线。
2.vertical-align:top 就是垂直上边缘对齐，如果是内联元素，则和这一行的位置最高的内联元素的顶部对齐。如果display计算值是table-cell。不妨脑补成<td>元素,则和<tr>元素上边缘对齐。
3.vertical-align:middle 是两边对齐，对于内联元素，元素的垂直中心和行框盒子基线往上1/2 x-height处对齐。对于table-cell元素，单元格填充盒子相对于外面的的表格行居中对齐。把此元素放置在父元素的中部。
4.vartical-align支持数值型属性，根据数据不同，相对于基线向上或者向下偏移，如果是负值，往下偏移，如果是正值，往上偏移。
5.vartical-align属性的百分比值则是根据line-height的计算值计算的。
6.vartical-align起作用是由前提条件的，这个前提条件就是:只能运用于内联盒子或者display为table-cell的元素。
7.table-cell元素设置vertical-align垂直对齐的是子元素，但是起作用的是元素自身。
8.bottom 把元素的顶端与行中最低的元素的顶端对齐。
```

## overflow的特殊性

```
1.一个设置了overflow:hidden声明的元素，当子元素的内容超出了容器的宽度和高度限制的时候，剪切的边界时=是border内边界而不是padding内边界。
2.HMTL中有两个标签默认可以产生滚动条一个时根元素<html> 一个时文本域<textarea>
3.滚动条会占用容器的宽度和高度。
4.元素设置了overflow:hidden声明,里面高度溢出的时候，滑动依然存在，仅仅滑动条不存在。
```

## 无依赖绝对定位是什么

```
没有设置 top/bottom/left/right 的绝对定位称为"无依赖绝对定位"
无依赖绝对定位和没有设置position:absolve时候的位置相关。
```

## absolute与overflow的关系？

```
1.如果overflow不是绝对定位，同时绝对定位元素和overflow容器之间没有定位元素，则无法对absolute进行剪裁。
2.如果overflow的值不是hidden而是auto或者scroll，即使绝对元素高度比overflow元素宽度还要大，也不会出现滚动条。
3.overflow自身transfrom的时候，chrome和opear浏览器下的overflow剪裁是无效的。
```

## clip裁剪是什么？

```
所谓"可访问性隐藏"，指的是虽然内容肉眼看不见，但是其他辅助设备却能够进行识别和访问的隐藏。
clip剪裁被我称为"最佳访问隐藏"的另外一个主要原因就是，它具有更强的普遍适应性，任何元素，任何场景都可以无障碍使用。
clip剪切绝对定位元素。
```

## relative的特殊性？

```
1.相对定位元素的left/top/right/bottom的百分比值是相对于包含块计算的，而不是自身。注意，虽然定位位移是相对于自身，但是百分比值的计算值不是。
2.top和bottom这两个垂直方向的百分比值计算跟height的百分比值一样，都是相对于高度计算的。同时，如果包含块的高度为auto，那么计算值是0，偏移无效，也就是说，如果父元素没有设置高度或者不是"格式化高度",那么relative类似于top：20%d的代码等同于0。
3.当相对元素同时应用对立方向进行定位的时候，也就是top/bottom,left/right同时使用的时候只有一个方向的定位属性会起到作用。因为文档流是自上而下，从左往右，因此top/bottom同时使用的时候 bottom失效，left/right同时使用的时候 right失效。
```

## position的属性

```
absolute：生成绝对定位的元素，相对于 static 定位以外的第一个父元素进行定位。
fixed：生成绝对定位元素。当对于浏览器窗口进行定位。
relative：生成相对定位，相对于其正常位置进行定位。
static：默认值，没有定位。
inherit：继承父元素的position属性
```

## 什么是层叠上下文

```
层叠上下文是HTML中的一个三维的概念。如果一个元素含有层叠上下文，那么它在x轴上就高人一等。
层叠上下文元素右如下特征：
1.层叠上下文的层叠水平要比普通元素高。
2.层叠上下文可以阻断元素的混杂模式。
3.层叠上下文可以嵌套，内部层叠上下文及其所有的子元素均受限于外部的层叠上下文。
4.每个层叠上下文都和兄弟独立，也即是说，当进行层叠变化或者渲染的时候，只考虑后代元素。
5.每个层叠上下文是自成体系的，当元素发生层叠的时候，整个元素被认为是在父层叠上下文的层叠顺序中。

层叠上下文的创建:
1.页面根元素天生具有层叠上下文，称为层叠上下文。根层叠上下文指的是页面根元素，可以看成是html元素。因此，页面中所有元素一定存在至少一个"层叠结界"中。
2.对于设置position值为relative/absolute z-index的值不为auto的定位元素。设置position:fixed的定位元素,z-index为任意。
3.其他一些CSS3属性。比如元素的opacity的值不是1。
```

## 什么是层叠水平

```
层叠水平，决定同一个层叠上下中在z轴上的显示顺序。
显而易见，所有的元素都有层叠水平，包括层叠上下文，也包括普通原本是。然而，对于普通元素的层叠水平探讨只局限于在当前这个层叠上下文元素中
```

## 元素的层叠顺序

```
层叠顺序:表示元素发生层叠时有着待定的层叠顺序。
层级上下文->负z-index->block块级水平盒子->float浮动盒子->inline水平盒子->z-index为0或者auto->正的z-index
```

## 层叠准则

```
谁大谁上:当具有明显的层叠水平标识的时候,如生效的z-index的属性值，在同一个层叠上下文领域，层叠水平值大的会覆盖小的那一个。
后来居上:当元素的层叠水平一致、层叠顺序相同的时候，在DOM流中处于后面的元素会覆盖前面的元素
```

## font-weight的特殊性

```
font-weight 属性设置文本的粗细。如果使用数值作为font-weight的属性值，必须是100~900的整百数值。因为这里的数值仅仅是外表长的像数值，实际上是一个具有特殊含义的关键字，并且这里的数值关键字和字母关键字之间是有对应关系的。
```

## text-indent的特殊性

```
text-indent 属性规定文本块中首行文本的缩进。
1.仅对第一行内联盒子内容有效。
2.非替换元素以外的display计算值为inline的内联属性设置text-indent值无效，如果计算值inline-block/inline-table则有效
3.input标签按钮text-index值无效
4.button标签按钮text-index值有效
5.text-index的百分比的值是相对于包含块计算的，而不是当前元素。
```

## letter-spacing与字符间距

```
letter-spacing可以控制字符之间的间距,这里说的"字符"包括英文字符，中文以及空格等，
letter-spacing具有以下特性。
1.继承性
2.默认值是normal而不是0。虽然说正常情况下，normol的计算值是0，但是两者还是有差异的，在有些场景下，letter-spacing会调整normal的计算值以实现更好的版面布局。
3.支持负值，且值足够大的时候，会让字符形成重叠，甚至反向排列。
4.支持小数值，即使0.1px也是支持的。
6.暂不支持百分比。
```

## word-spacing与单词间隔

```
letter-spcaing是作用所有字符，单word-spacing仅作用于空格字符。word-spacing的作用就是增加字符之间的间隔宽度。
```

## white-space与换行和空格的控制？

```
white-space属性声明了如何处理元素内的空白字符，这里的空白字符包括Space(空格)键,Enter(回车),Tab(制表符)键产生的空白。因此white-space可以决定图文内容是否一行显示，是否显示大段连续空格。

其属性值包括
normal:合并空白格和换行符。
pre:空白格不合并，并且内容在有换行符的地方换行。
nowrap:该值和normal一样会合并空白符，但不允许文本环绕。
pre-wrap:空白符不合并,并且内容只有在有换行符的地方换行，同时允许文本环绕。
pre-line:合并空白符,但只有在换行符的地方换行，允许文字环绕

个人理解
normal:默认属性 合并空格 合并换行
pre:不合并空格，换行
noworp:不换行，合并空格
```

## 隐藏元素的background-image到底加载不加载？

```
1.元素的背景图片
	-元素设置display:none,会请求图片。
	-父元素设置display:none,不会发送请求。
	-如果设置的样式没有对应的元素,则background也不会加载。
	-hover情况下的background在触发时加载。
2.img标签图片任何情况下都会请求图片
```

## px,em,rem区别

```
px:相对单位，相对于显示屏的分辨率而言的。(相对于物理像素)
em:相对尺寸 相对于父元素字体大小。如果当前对象内文字大小未被设定，则相对于浏览器的默认字体尺寸。
rem:相对于根节点html的字体大小
```

## 如何实现单行/多行 的省略(....)

```css
/*单行文本溢出*/
p{
    width:12em;
    overflow:hidden;
	text-overflow:ellipsis;/*显示省略符代替被切文本*/
	white-space:nowarp;
}
/*多行文本溢出*/
p{
    position:relative;
    overflow:hidden;
    line-heigth:1.5em;
    height:3em;
}
p::after{
    content:'...';
    position:absolute;
    bottom:0;
    right:0;
}
```

## 常见的元素隐藏方式

```
1.display:none。不会在页面中占据位置。不会响应绑定响应事件
2.visibility:hidden。会在页面中占据空间。不会绑定响应事件
3.opacity:0。将元素的透明度设置为0，以此来实现元素的隐藏。元素在页面中占据空间，并且能够响应元素绑定监听事件。
4.利用绝对定位移除可视区域。
5.通过z-index负值，来使其他元素来遮盖该元素。
6.clip元素剪切。
7.treasform:scale
```

## css实现上下固定中间自适应

```html
/* 通过绝对定位和相对定位来实现 */
/* 首先初始化 */
*{
	margin:0;
	padding0;
}
header 绝对定位 top设置为0 宽度100% 高度100px
container 绝对定位 top设置为100px bottom设置为100px 宽度100%
footer 绝对定位 bottom设置0px height设置100px 
/*html*/
<div class="header"></div>
<div class="container"></div>
<div class="footer"></div>

/*利用flex实现*/
html,body{
    height: 100%;
}
body{
    margin: 0;
    padding: 0;
    display: flex;
    flex-direction: column;
}
.header{
    height: 100px;
    background-color: sienna;
}
.container{
    flex:1;
    background-color: slateblue;
}
.footer{
    height: 100px;
    background-color: teal;
}
```

## 两栏布局

```
1.左元素设置float并设置宽度为100px 右元素设置margin-left=100px width:auto即可
2.flex布局 左元素宽度100px 右元素flex:1 即可
3.左元素设置绝对定位 右元素设置margin-left。
利用相对绝对定位 将父元素设置相对定位，左边设置绝对定位，并且宽度设置为100px，将右边元素的margin-left的值设置为100px(absolute 会让元素脱离文档流 right会直接顶上去 所以我们需要设置margin-left div宽度默认是100%，但是当设置了absolute之后宽度不再是100%,宽度由内容宽度决定)
有两个方法：
	1.直接设置 width:100%
	2.设置left:0px   right:0px;
4.右元素设置绝对定位 left:100px 其余都是0 左元素宽度设置100px
```

## CSS三栏布局

```
三栏布局一般指的是页面中一共有三栏，左右两栏宽度固定，中间自适应。
这里以左边宽度为100px 右变200px距离。
1.利用绝对定位的方式，左右两栏设置为绝对定位，中间设置margin的值
2.利用flex布局 左右两边设置宽度 中间设置flex:1
3.利用浮动的方式，左右两栏分别设置左，右浮动。中间一栏设置margin的值，注意这种中间一栏必须放到最后。
4.圣杯布局。中间在最前 然后左右。
首先三个浮动 然后放在一个盒子里通过padding 来预留位置 通过margin-left来进行移动(左边是-100% 右边是-200px) 然后通过相对定位移动
5.双飞翼布局。中间在最前然后左右。
把内容外面加个div宽度设置100% 这个盒子和左右盒子都浮动起来。设置margin-left right 来预留位置 左边和右边的元素通过 margin-left来移动 左边移动margin-left大小 右边移动元素的内容
```

## 实现一个自适应的正方形

```
1.通过vw来实现 vw相对于视口的宽度，视口被均分为100单位的vw
.one{
    width: 10%;
    height:10vw;
    background-color: darkblue;
}
2.利用padding-bottom设置垂直方式来撑开容器
在css盒子模型中，margin，padding的百分比数值是通过相对父元素的宽度进行计算的，只需将padding和width设置同一个百分比即可。同时将height设置为0 防止影响。
.two{
    width: 20%;
    height: 0;
    padding-bottom: 20%;
    background-color: darkkhaki;
}
3.利用伪类元素撑开容器 使用margin-top/padding-top 如果是垂直方向上的margin撑开元素，仅仅设置伪元素是不够的，这涉及到margin重叠问题，由于容器与伪元素在垂直方向发生了外边距合并，所以撑开父元素高度并没有出现，解决办法是在父元素上触发BFC:设置overflow:hidden。
```

## link标签和import标签的区别

link属于html标签 ，而 @import是css提供得到。

页面被加载时，link会同时被加载，而@impot引用的css会等到页面加载接受后加载。

link是html标签所以没有兼容性问题，而import是css提供的只有IE5以上才能识别。

link方法样式权级高于@import。
